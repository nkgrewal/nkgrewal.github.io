package com.asd{	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.Stage;	import flash.display.BlendMode;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.AntiAliasType;	import memorphic.xpath.XPathQuery;	import gs.*;	import gs.easing.*;	import gs.plugins.*;		public class Focuses extends MovieClip	{		private var focusXML:XML = new XML( );		private var focusLoader:URLLoader = new URLLoader( );		private var key:String = "";		private var focusList:XMLList;		private var programList:XMLList;		private var tf:TextFormat;		private var tf2:TextFormat;		private var par;		private var focusMC:MovieClip;		private var degrees:MovieClip;		private var clickedFocus:String;		private var thePane:String;				public function Focuses( p, pane:String )		{			// activate TweenLite			TweenPlugin.activate([EndArrayPlugin, DropShadowFilterPlugin, VolumePlugin, TintPlugin, FramePlugin, AutoAlphaPlugin, RemoveTintPlugin, VisiblePlugin]);						// set the parent			par = p;						// which pane is it supposed to be?			thePane = pane						// text formatter			tf = new TextFormat( );			tf.font = "Helvetica";			tf.color = "0xffffff";			tf.align = "center";			tf.bold = true;			tf.size = 14;						tf2 = new TextFormat( );			tf2.font = "Helvetica";			tf2.color = "0x003366";			tf2.size = 30;			tf2.bold = true;						// set up listeners			focusLoader.addEventListener( Event.COMPLETE, loadFocusXML );			focusLoader.load( new URLRequest( "focuses.xml" ) );						degrees = new MovieClip( );			degrees.alpha = 0;			this.addChild( degrees );						focusMC = new MovieClip( );			this.addChild( focusMC );		}				function loadFocusXML(e:Event):void		{			focusXML = new XML(e.target.data);						if ( thePane == "focus" )			{				if ( par.theState == "" )				{					q = new XPathQuery( "//key[contains( @id, '_" + par.theDegree + "' )]" );					par.stateKeys = q.exec( par.statesXML );									//trace( "sk " + par.stateKeys.length( ) + " ::\n" + par.stateKeys.toString( ) );				}								showFocus( );			}			else			{				if ( par.theState == "" )				{					q = new XPathQuery( "//key[starts-with( @id, '" + par.theProgram + "' )]" );										par.stateKeys = q.exec( par.statesXML );				}								showDegrees( );			}		}				// shows the initial set of programs		public function showFocus( ):void		{			var fCopy:TextField = new TextField( );			fCopy.width = 427;			fCopy.x = 10;			fCopy.y = 20;			fCopy.multiline = true;			fCopy.wordWrap = true;			fCopy.antiAliasType = AntiAliasType.ADVANCED;			fCopy.selectable = false;			fCopy.embedFonts = true			fCopy.text = "What program are you looking for?";			fCopy.setTextFormat( tf2 );			fCopy.height = fCopy.textHeight + 5;			focusMC.addChild( fCopy );						var programArr:Array = new Array( );			var i, j;			var tmpObj:Object;						// check to see if a state has been selected, if it has, then we need to widdle down the programs			if ( par.theState != "" )			{				for ( i in par.stateKeys )				{					var found:Boolean = false;					var tmpProgram:String = par.stateKeys[ i ].attribute( "id" ).split( "_" )[ 0 ];										for ( j in programArr )					{						if ( programArr[ j ].theID.split( "_" )[ 0 ] == tmpProgram )							found = true;					}										if ( !found )					{						// add the node from the XML to the new array						for ( var k in focusXML.children( ) )						{							if ( focusXML.children( )[ k ].attribute( "id" ) == tmpProgram )								programArr.push( { theID:focusXML.children( )[ k ].attribute( "id" ), theName:focusXML.children( )[ k ].attribute( "name" ) } );						}					}				}						// check to see if the degree has been chosen before the program			} else if ( par.theDegree != "" && par.theState == "" ) {				// set up a XPath Query to get all of the focuses with a specific degree type				var q:XPathQuery = new XPathQuery( "//degree[@id='" + par.theDegree + "']/.." );				var res:XMLList = q.exec( focusXML );								for ( i in res )				{					programArr.push( { theID:res[ i ].attribute( "id" ), theName:res[ i ].attribute( "name" ) } );				}						// if a state hasn't been selected, show em all			} else {				for ( i in focusXML.children( ) )				{					programArr.push( { theID:focusXML.children( )[ i ].attribute( "id" ), theName:focusXML.children( )[ i ].attribute( "name" ) } );				}			}						// row height			var rowH:uint = Math.ceil( programArr.length / 2 );			var startY:uint = ( stage.stageHeight - ( rowH * 35 ) ) / 2 + 45;						for ( i in programArr )			{				var sp:Sprite = new Sprite( );				sp.name = "sp" + programArr[ i ].theID;				sp.graphics.beginFill( 0x336699, .8 );				sp.graphics.lineStyle( 6, 0xffffff, .5 );				sp.graphics.drawRoundRect(0, 0, 200, 30, 10, 10 );				sp.graphics.endFill( );				sp.y = ( i % rowH ) * 35 + startY;				sp.x = Math.floor( i / rowH ) * 205 + 20;				sp.alpha = 1;				sp.buttonMode = true;				sp.mouseChildren = false;				sp.blendMode = BlendMode.LAYER;								sp.addEventListener( MouseEvent.ROLL_OVER, spOver );				sp.addEventListener( MouseEvent.ROLL_OUT, spOut );				sp.addEventListener( MouseEvent.CLICK, clickFocus );								var txt:TextField = new TextField( );				txt.name = "txt";				txt.width = 200;				txt.antiAliasType = AntiAliasType.ADVANCED;				txt.text = programArr[ i ].theName;				txt.setTextFormat( tf );				txt.multiline = false;				txt.wordWrap = false;				txt.selectable = false;				txt.embedFonts = true;				txt.height = txt.textHeight + 5;				txt.blendMode = BlendMode.ERASE;				txt.y = 7;								sp.addChild( txt );								focusMC.addChild( sp );			}		}				// shows the degree types		public function showDegrees( ):void		{			// selected focus			var foc:String = par.theProgram;			var timelineArr:Array = new Array( "6-12", 12, 24, 48 );						degrees.alpha = 0;						var fCopy:TextField = new TextField( );			fCopy.width = 300;			fCopy.x = 10;			fCopy.y = 20;			fCopy.multiline = true;			fCopy.wordWrap = true;			fCopy.antiAliasType = AntiAliasType.ADVANCED;			fCopy.selectable = false;			fCopy.embedFonts = true			fCopy.text = "What degree type are you looking for?";			fCopy.setTextFormat( tf2 );			fCopy.height = fCopy.textHeight + 5;			degrees.addChild( fCopy );						// set up the XPath Query			var q:XPathQuery;			if ( par.theProgram == "" )				q = new XPathQuery( "//degree" );			else				q = new XPathQuery( "//focus[@id='" + foc + "']/degree" );						var res:XMLList = q.exec( focusXML );						// grab just one of each			var tmpArr:Array = new Array( );						//trace( res.toString( ) + "\n" );									// check to see if a state has been selected, if it has, then we need to widdle down the programs			// if a state hasn't been selected, just grab one of each			for ( var i in res )			{				var found:Boolean = false;				var stateMatch:Boolean = false;								if ( par.theProgram != "" )				{					// loop through the state keys					for ( var j in par.stateKeys )					{						var tmpProgram:String = par.stateKeys[ j ].attribute( "id" ).split( "_" )[ 0 ];						var tmpDegree:String = par.stateKeys[ j ].attribute( "id" ).split( "_" )[ 1 ];												if ( tmpDegree == res[ i ].attribute( "id" ) && tmpProgram == foc )							stateMatch = true;					}				}				else					stateMatch = true;								for ( var k in tmpArr )				{					if ( tmpArr[ k ].attribute( "id" ) == res[ i ].attribute( "id" ) )						found = true;				}								// if it's not found, and it matches with the state's program (or no state is selected) then add it to the tmpList				if ( !found && stateMatch )					tmpArr.push( res[ i ] );			}						var rowH:uint = Math.ceil( tmpArr.length / 2 );			var startY:uint = ( stage.stageHeight - ( rowH * 35 ) ) / 2 + 45;						for ( i in tmpArr )			{				var sp:Sprite = new Sprite( );				sp.name = "sp" + tmpArr[ i ].attribute( "id" );				sp.graphics.beginFill( 0x336699, .8 );				sp.graphics.lineStyle( 6, 0xffffff, .5 );				sp.graphics.drawRoundRect(0, 0, 200, 30, 10, 10 );				sp.graphics.endFill( );				sp.y = ( i % rowH ) * 35 + startY;				sp.x = Math.floor( i / rowH ) * 205 + 20;				sp.alpha = 1;				sp.buttonMode = true;				sp.mouseChildren = false;				sp.blendMode = BlendMode.LAYER;								sp.addEventListener( MouseEvent.ROLL_OVER, spOver );				sp.addEventListener( MouseEvent.ROLL_OUT, spOut );				sp.addEventListener( MouseEvent.CLICK, clickDegree );								var txt:TextField = new TextField( );				txt.name = "txt";				txt.width = 200;				txt.antiAliasType = AntiAliasType.ADVANCED;								// if the completion date was selected first, show an amount of time				if ( par.theState == "" && timelineArr[ i ] != null )					txt.text = tmpArr[ i ].attribute("name")  + " (" + timelineArr[ i ] + " Months)";				else					txt.text = tmpArr[ i ].attribute("name");				txt.setTextFormat( tf );				txt.multiline = false;				txt.wordWrap = false;				txt.selectable = false;				txt.embedFonts = true;				txt.height = txt.textHeight;				txt.y = 7;				txt.blendMode = BlendMode.ERASE;								sp.addChild( txt );								degrees.addChild( sp );			}						degrees.rotationY = -60;						TweenLite.to( degrees, 1, { alpha:1, rotationY:0, delay:.5 } );		}				private function spOver( e:MouseEvent ):void		{			var tgt = e.target;						TweenLite.to( tgt, .5, { alpha:1, tint:0x339966 } );		}				private function spOut( e:MouseEvent ):void		{			var tgt = e.target;						TweenLite.to( tgt, .75, { alpha:1, removeTint:true } );		}				private function clickFocus( e:MouseEvent ):void		{			var tgt = e.target;			if ( tgt.name.indexOf( "sp" ) < 0 )			{				tgt = tgt.parent;			}						par.theProgram = tgt.name.substr( 2 );			par.gotoNextSection( );		}				private function clickDegree( e:MouseEvent ):void		{			var tgt = e.target;			if ( tgt.name.indexOf( "sp" ) < 0 )				tgt = tgt.parent;						par.theDegree = tgt.name.substr( 2 ) + "";			par.gotoNextSection( );		}	}}